# -*- coding: utf-8 -*-
"""Week03Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZYxkGP6TGKm0VRw3ORZMst_430XhppwX
"""

import pandas as pd
import numpy as np
from math import *
import timeit

df = pd.read_csv('clinics.csv', sep='|')
df.head()

def haversine(lat1, lon1, lat2, lon2):
    miles_constant = 3959
    lat1, lon1, lat2, lon2 = map(np.deg2rad, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
    c = 2 * np.arcsin(np.sqrt(a))
    mi = miles_constant * c
    return mi

# Commented out IPython magic to ensure Python compatibility.
# #Haversine applied using simple for loop logic
# %%timeit
# haversine_series = []
# for i in range(len(df)):
#     haversine_series.append(haversine(40.671, -73.985,\
#                                       df.loc[i, 'locLat'], df.loc[i, 'locLong']))

# Commented out IPython magic to ensure Python compatibility.
# # Haversine applied on rows via iteration
# %%timeit
# haversine_series = []
# for index, row in df.iterrows():
#     haversine_series.append(haversine(40.671, -73.985,\
#                                       row['locLat'], row['locLong']))
# df['distance'] = haversine_series

# Commented out IPython magic to ensure Python compatibility.
#Haversine applied using Apply function
# %timeit df['distance'] = df.apply(lambda row: haversine(40.671, -73.985,\
                               row['locLat'], row['locLong']), axis=1)

# Commented out IPython magic to ensure Python compatibility.
#Haversine applied using Pandas Vectorized
# %timeit df['distance'] = haversine(40.671, -73.985,\
                                   df['locLat'], df['locLong'])

# Commented out IPython magic to ensure Python compatibility.
#Haversine applied using NumPy vectorized
# %timeit df['distance'] = haversine(40.671, -73.985,\
                         df['locLat'].values, df['locLong'].values)

# Commented out IPython magic to ensure Python compatibility.
# %load_ext cython

# Commented out IPython magic to ensure Python compatibility.
# %%cython -a
# # Haversine cythonized
# from libc.math cimport sin, cos, acos, asin, sqrt
# 
# cdef deg2rad_cy(float deg):
#     cdef float rad
#     rad = 0.01745329252*deg
#     return rad
# 
# cpdef haversine_cy_dtyped(float lat1, float lon1, float lat2, float lon2):
#     cdef:
#         float dlon
#         float dlat
#         float a
#         float c
#         float mi
# 
#     lat1, lon1, lat2, lon2 = map(deg2rad_cy, [lat1, lon1, lat2, lon2])
#     dlat = lat2 - lat1
#     dlon = lon2 - lon1
#     a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
#     c = 2 * asin(sqrt(a))
#     mi = 3959 * c
#     return mi

# Commented out IPython magic to ensure Python compatibility.
# %timeit df['distance'] =\
       df.apply(lambda row: haversine_cy_dtyped(40.671, -73.985,\
                row['locLat'], row['locLong']), axis=1)